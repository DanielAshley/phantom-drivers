diff -N -r -u /home/bzr/Downloads/libraw1394-2.0.5/src/dispatch.c ./src/dispatch.c
--- /home/bzr/Downloads/libraw1394-2.0.5/src/dispatch.c	2009-06-22 06:22:25.000000000 +0200
+++ ./src/dispatch.c	2010-09-01 10:08:04.000000000 +0200
@@ -17,6 +17,8 @@
 #include "raw1394_private.h"
 #include "fw.h"
 
+#include "trace.h"
+
 int raw1394_errcode_to_errno(raw1394_errcode_t errcode)
 {
 	return ieee1394_errcode_to_errno(errcode);
@@ -28,10 +30,14 @@
 	fw_handle_t fw_handle;
 	raw1394handle_t handle;
 	struct raw1394_portinfo port;
+	TRACE("raw1394_new_handle()");
 
 	handle = (raw1394handle_t) malloc(sizeof(struct raw1394_handle));
 	if (!handle)
+  {
+  	TRACEret("failed");
 		return NULL;
+  }
 
 	ieee1394_handle = ieee1394_new_handle();
 	if (!ieee1394_handle)
@@ -40,6 +46,7 @@
 	if (ieee1394_get_port_info(ieee1394_handle, &port, 1) >= 1) {
 		handle->is_fw = 0;
 		handle->mode.ieee1394 = ieee1394_handle;
+  	TRACEret1("returned ieee1394 handle %d", get_handle_number(handle));
 		return handle;
 	}
 	ieee1394_destroy_handle(ieee1394_handle);
@@ -48,15 +55,19 @@
 	if (fw_handle) {
 		handle->is_fw = 1;
 		handle->mode.fw = fw_handle;
+  	TRACEret1("returned fw handle %d", get_handle_number(handle));
 		return handle;
 	}
 
 	free(handle);
+	TRACEret("failed");
 	return NULL;
 }
 
 void raw1394_destroy_handle(raw1394handle_t handle)
 {
+	TRACEh("raw1394_destroy_handle(h = %d)", handle);
+
 	if (!handle) {
 		return;
 	}
@@ -64,6 +75,9 @@
 		fw_destroy_handle(handle->mode.fw);
 	else
 		ieee1394_destroy_handle(handle->mode.ieee1394);
+
+	remove_handle_number(handle); // Make sure we do not use it anymore
+	TRACEret("");
 	free(handle);
 }
 
@@ -73,14 +87,20 @@
 	fw_handle_t fw_handle;
 	raw1394handle_t handle;
 
+	TRACE1("raw1394_new_handle_on_port(%d)", port);
+
 	handle = (raw1394handle_t) malloc(sizeof(struct raw1394_handle));
 	if (!handle)
+  {
+  	TRACEret("failed!");
 		return NULL;
+  }
 
 	ieee1394_handle = ieee1394_new_handle_on_port(port);
 	if (ieee1394_handle) {
 		handle->is_fw = 0;
 		handle->mode.ieee1394 = ieee1394_handle;
+  	TRACEret1("returned ieee1394 handle %d", get_handle_number(handle));
 		return handle;
 	}
 
@@ -88,120 +108,178 @@
 	if (fw_handle) {
 		handle->is_fw = 1;
 		handle->mode.fw = fw_handle;
+  	TRACEret1("returned fw handle %d", get_handle_number(handle));
 		return handle;
 	}
 
 	free(handle);
+	TRACEret("failed!");
 	return NULL;
 }
 
 int raw1394_busreset_notify (raw1394handle_t handle, int off_on_switch)
 {
+	TRACEh1("raw1394_busreset_notify(h = %d, %d)", handle, off_on_switch);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+
+	int ret;
 	if (handle->is_fw)
-		return fw_busreset_notify(handle->mode.fw, off_on_switch);
+		ret = fw_busreset_notify(handle->mode.fw, off_on_switch);
 	else
-		return ieee1394_busreset_notify(handle->mode.ieee1394, off_on_switch);
+		ret = ieee1394_busreset_notify(handle->mode.ieee1394, off_on_switch);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_get_fd(raw1394handle_t handle)
 {
+	TRACEh("raw1394_get_fd(h = %d)", handle);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+
+	int ret;
 	if (handle->is_fw)
-		return fw_get_fd(handle->mode.fw);
+		ret = fw_get_fd(handle->mode.fw);
 	else
-		return ieee1394_get_fd(handle->mode.ieee1394);
+		ret = ieee1394_get_fd(handle->mode.ieee1394);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 nodeid_t raw1394_get_local_id(raw1394handle_t handle)
 {
+	TRACEh("raw1394_get_local_id(h = %d)", handle);
 	if (!handle) {
 		errno = EINVAL;
 		return 0xFFFF;
 	}
+
+  nodeid_t ret;
 	if (handle->is_fw)
-		return fw_get_local_id(handle->mode.fw);
+		ret = fw_get_local_id(handle->mode.fw);
 	else
-		return ieee1394_get_local_id(handle->mode.ieee1394);
+		ret = ieee1394_get_local_id(handle->mode.ieee1394);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 nodeid_t raw1394_get_irm_id(raw1394handle_t handle)
 {
+	TRACEh("raw1394_get_irm_id(h = %d)", handle);
 	if (!handle) {
 		errno = EINVAL;
 		return 0xFFFF;
 	}
+
+	nodeid_t ret;
 	if (handle->is_fw)
-		return fw_get_irm_id(handle->mode.fw);
+		ret = fw_get_irm_id(handle->mode.fw);
 	else
-		return ieee1394_get_irm_id(handle->mode.ieee1394);
+		ret = ieee1394_get_irm_id(handle->mode.ieee1394);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_get_nodecount(raw1394handle_t handle)
 {
+	TRACEh("raw1394_get_nodecount(h = %2d)", handle);
+
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+
+	int ret;
 	if (handle->is_fw)
-		return fw_get_nodecount(handle->mode.fw);
+		ret = fw_get_nodecount(handle->mode.fw);
 	else
-		return ieee1394_get_nodecount(handle->mode.ieee1394);
+		ret = ieee1394_get_nodecount(handle->mode.ieee1394);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_get_port_info(raw1394handle_t handle, struct raw1394_portinfo *pinf,
                           int maxports)
 {
+	TRACEh1("raw1394_get_port_info(h = %d, buffer, maxports = %d)", handle, maxports);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+
+	int ret;
 	if (handle->is_fw)
-		return fw_get_port_info(handle->mode.fw, pinf, maxports);
+		ret = fw_get_port_info(handle->mode.fw, pinf, maxports);
 	else
-		return ieee1394_get_port_info(handle->mode.ieee1394, pinf, maxports);
+		ret = ieee1394_get_port_info(handle->mode.ieee1394, pinf, maxports);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_set_port(raw1394handle_t handle, int port)
 {
+	TRACEh1("raw1394_set_port(h = %d, port = %d)", handle, port);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_set_port(handle->mode.fw, port);
+		ret = fw_set_port(handle->mode.fw, port);
 	else
-		return ieee1394_set_port(handle->mode.ieee1394, port);
+		ret = ieee1394_set_port(handle->mode.ieee1394, port);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_reset_bus_new(raw1394handle_t handle, int type)
 {
+	TRACEh1("raw1394_reset_bus_new(h = %d, type = %d)", handle, type);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_reset_bus_new(handle->mode.fw, type);
+		ret = fw_reset_bus_new(handle->mode.fw, type);
 	else
-		return ieee1394_reset_bus_new(handle->mode.ieee1394, type);
+		ret = ieee1394_reset_bus_new(handle->mode.ieee1394, type);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_loop_iterate(raw1394handle_t handle)
 {
+#ifdef TRACELOOP
+	TRACEh("raw1394_loop_iterate(h = %d)", handle);
+#endif
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_loop_iterate(handle);
+		ret = fw_loop_iterate(handle);
 	else
-		return ieee1394_loop_iterate(handle);
+		ret = ieee1394_loop_iterate(handle);
+
+#ifdef TRACELOOP
+	TRACEret1("%d", ret);
+#endif
+	return ret;
 }
 
 int raw1394_arm_register(raw1394handle_t handle, nodeaddr_t start,
@@ -210,158 +288,219 @@
                          arm_options_t notification_options,
                          arm_options_t client_transactions)
 {
+	TRACEh("raw1394_arm_register(h = %d, ...)", handle);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_arm_register(handle->mode.fw, start, length, initial_value,
+		ret = fw_arm_register(handle->mode.fw, start, length, initial_value,
 			arm_tag, access_rights, notification_options, client_transactions);
 	else
-		return ieee1394_arm_register(handle->mode.ieee1394, start, length,
+		ret = ieee1394_arm_register(handle->mode.ieee1394, start, length,
 			initial_value, arm_tag, access_rights, notification_options,
 			client_transactions);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_arm_unregister(raw1394handle_t handle, nodeaddr_t start)
 {
+	TRACEh1("raw1394_arm_unregister(h = %d, start = 0x%lx)", handle, start);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_arm_unregister(handle->mode.fw, start);
+		ret = fw_arm_unregister(handle->mode.fw, start);
 	else
-		return ieee1394_arm_unregister(handle->mode.ieee1394, start);
+		ret = ieee1394_arm_unregister(handle->mode.ieee1394, start);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_arm_set_buf (raw1394handle_t handle, nodeaddr_t start,
                          size_t length, void *buf)
 {
+	TRACEh1("raw1394_arm_set_buf(h = %d, start = 0x%lx, length = %ld, buf)", handle, start, length);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+
+	int ret;
 	if (handle->is_fw)
-		return fw_arm_set_buf(handle->mode.fw, start, length, buf);
+		ret = fw_arm_set_buf(handle->mode.fw, start, length, buf);
 	else
-		return ieee1394_arm_set_buf(handle->mode.ieee1394, start, length, buf);
+		ret = ieee1394_arm_set_buf(handle->mode.ieee1394, start, length, buf);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_arm_get_buf (raw1394handle_t handle, nodeaddr_t start,
                          size_t length, void *buf)
 {
+	TRACEh1("raw1394_arm_get_buf(h = %d, start = 0x%lx, length = %ld, buf)", handle, start, length);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_arm_get_buf(handle->mode.fw, start, length, buf);
+		ret = fw_arm_get_buf(handle->mode.fw, start, length, buf);
 	else
-		return ieee1394_arm_get_buf(handle->mode.ieee1394, start, length, buf);
+		ret = ieee1394_arm_get_buf(handle->mode.ieee1394, start, length, buf);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_echo_request(raw1394handle_t handle, quadlet_t data)
 {
+	TRACEh("raw1394_echo_request(h = %d, date)", handle);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_echo_request(handle->mode.fw, data);
+		ret = fw_echo_request(handle->mode.fw, data);
 	else
-		return ieee1394_echo_request(handle->mode.ieee1394, data);
+		ret = ieee1394_echo_request(handle->mode.ieee1394, data);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_wake_up(raw1394handle_t handle)
 {
+	TRACEh("raw1394_wake_up(h = %d)", handle);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_wake_up(handle->mode.fw);
+		ret = fw_wake_up(handle->mode.fw);
 	else
-		return ieee1394_wake_up(handle->mode.ieee1394);
+		ret = ieee1394_wake_up(handle->mode.ieee1394);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_phy_packet_write (raw1394handle_t handle, quadlet_t data)
 {
+	TRACEh("raw1394_phy_packet_write(h = %d, data)", handle);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_phy_packet_write(handle->mode.fw, data);
+		ret = fw_phy_packet_write(handle->mode.fw, data);
 	else
-		return ieee1394_phy_packet_write(handle, data);
+		ret = ieee1394_phy_packet_write(handle, data);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_start_phy_packet_write(raw1394handle_t handle,
         quadlet_t data, unsigned long tag)
 {
+	TRACEh("raw1394_start_phy_packet_write(h = %d, data, tag)", handle);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_start_phy_packet_write(handle->mode.fw, data, tag);
+		ret = fw_start_phy_packet_write(handle->mode.fw, data, tag);
 	else
-		return ieee1394_start_phy_packet_write(handle->mode.ieee1394, data, tag);
+		ret = ieee1394_start_phy_packet_write(handle->mode.ieee1394, data, tag);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_start_read(raw1394handle_t handle, nodeid_t node, nodeaddr_t addr,
                        size_t length, quadlet_t *buffer, unsigned long tag)
 {
+	TRACEh1("raw1394_start_read(h = %d, node = 0x%x, addr = 0x%lx, length = %ld, buffer, tag)", handle, node, addr, length);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_start_read(handle->mode.fw, node, addr, length, buffer, tag);
+		ret = fw_start_read(handle->mode.fw, node, addr, length, buffer, tag);
 	else
-		return ieee1394_start_read(handle->mode.ieee1394, node, addr, length, buffer, tag);
+		ret = ieee1394_start_read(handle->mode.ieee1394, node, addr, length, buffer, tag);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_start_write(raw1394handle_t handle, nodeid_t node, nodeaddr_t addr,
                         size_t length, quadlet_t *data, unsigned long tag)
 {
+	TRACEh1("raw1394_start_write(h = %d, node = 0x%x, addr = 0x%lx, length = %ld, buffer, tag)", handle, node, addr, length);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_start_write(handle->mode.fw, node, addr, length, data, tag);
+		ret = fw_start_write(handle->mode.fw, node, addr, length, data, tag);
 	else
-		return ieee1394_start_write(handle->mode.ieee1394, node, addr, length, data, tag);
+		ret = ieee1394_start_write(handle->mode.ieee1394, node, addr, length, data, tag);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_start_lock(raw1394handle_t handle, nodeid_t node, nodeaddr_t addr,
                        unsigned int extcode, quadlet_t data, quadlet_t arg,
                        quadlet_t *result, unsigned long tag)
 {
+	TRACEh1("raw1394_start_lock(h = %d, node = 0x%x, addr = 0x%lx, extcode = %u, data, arg, result, tag)", handle, node, addr, extcode);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_start_lock(handle->mode.fw, node, addr, extcode, data, arg, result, tag);
+		ret = fw_start_lock(handle->mode.fw, node, addr, extcode, data, arg, result, tag);
 	else
-		return ieee1394_start_lock(handle->mode.ieee1394, node, addr, extcode, data, arg, result, tag);
+		ret = ieee1394_start_lock(handle->mode.ieee1394, node, addr, extcode, data, arg, result, tag);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_start_lock64(raw1394handle_t handle, nodeid_t node, nodeaddr_t addr,
                        unsigned int extcode, octlet_t data, octlet_t arg,
                        octlet_t *result, unsigned long tag)
 {
+	TRACEh1("raw1394_start_lock64(h = %d, node = 0x%x, addr = 0x%lx, extcode = %u, data, arg, result, tag)", handle, node, addr, extcode);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_start_lock64(handle->mode.fw, node, addr, extcode, data, arg, result, tag);
+		ret = fw_start_lock64(handle->mode.fw, node, addr, extcode, data, arg, result, tag);
 	else
-		return ieee1394_start_lock64(handle->mode.ieee1394, node, addr, extcode, data, arg, result, tag);
+		ret = ieee1394_start_lock64(handle->mode.ieee1394, node, addr, extcode, data, arg, result, tag);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_start_async_stream(raw1394handle_t handle, unsigned int channel,
@@ -369,14 +508,19 @@
                                unsigned int speed, size_t length, quadlet_t *data,
                                unsigned long rawtag)
 {
+	TRACEh1("raw1394_start_async_stream(h = %d, channel = %u, tag, sy = %u, speed = %u, length = %ld, data, rawtag)", handle, channel, sy, speed, length);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_start_async_stream(handle->mode.fw, channel, tag, sy, speed, length, data, rawtag);
+		ret = fw_start_async_stream(handle->mode.fw, channel, tag, sy, speed, length, data, rawtag);
 	else
-		return ieee1394_start_async_stream(handle->mode.ieee1394, channel, tag, sy, speed, length, data, rawtag);
+		ret = ieee1394_start_async_stream(handle->mode.ieee1394, channel, tag, sy, speed, length, data, rawtag);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_start_async_send(raw1394handle_t handle,
@@ -384,84 +528,131 @@
                              unsigned int expect_response,
                              quadlet_t *data, unsigned long rawtag)
 {
+	TRACEh1("raw1394_start_async_stream(h = %d, length = %ld, header_length = %ld, expect_response = %u, data, rawtag)", handle, length, header_length, expect_response);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_start_async_send(handle->mode.fw, length, header_length,
+		ret = fw_start_async_send(handle->mode.fw, length, header_length,
 			expect_response, data, rawtag);
 	else
-		return ieee1394_start_async_send(handle->mode.ieee1394, length,
+		ret = ieee1394_start_async_send(handle->mode.ieee1394, length,
 			header_length, expect_response, data, rawtag);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_read(raw1394handle_t handle, nodeid_t node, nodeaddr_t addr,
                  size_t length, quadlet_t *buffer)
 {
+	TRACEh1("raw1394_read(h = %d, node = 0x%x, addr = 0x%lx, length = %ld, buffer)", handle, node, addr, length);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_read(handle, node, addr, length, buffer);
+		ret = fw_read(handle, node, addr, length, buffer);
 	else
-		return ieee1394_read(handle, node, addr, length, buffer);
+		ret = ieee1394_read(handle, node, addr, length, buffer);
+
+  if(length >= 4)
+  {
+  	TRACEquad("-> buffer", buffer, length);
+  }
+  else
+  {
+  	TRACEchar("-> buffer", buffer, length);
+  }
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_write(raw1394handle_t handle, nodeid_t node, nodeaddr_t addr,
                   size_t length, quadlet_t *data)
 {
+	TRACEh1("raw1394_write(h = %d, node = 0x%x, addr = 0x%lx, length = %ld, data)", handle, node, addr, length);
+  if(length >= 4)
+  {
+  	TRACEquad("<- data", data, length)
+  }
+  else
+  {
+  	TRACEchar("<- data", data, length)
+  }
+
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_write(handle, node, addr, length, data);
+		ret = fw_write(handle, node, addr, length, data);
 	else
-		return ieee1394_write(handle, node, addr, length, data);
+		ret = ieee1394_write(handle, node, addr, length, data);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_lock(raw1394handle_t handle, nodeid_t node, nodeaddr_t addr,
                  unsigned int extcode, quadlet_t data, quadlet_t arg,
                  quadlet_t *result)
 {
+	TRACEh1("raw1394_lock(h = %d, node = 0x%x, addr = 0x%lx, extcode = %u, data, arg, result)", handle, node, addr, extcode);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_lock(handle, node, addr, extcode, data, arg, result);
+		ret = fw_lock(handle, node, addr, extcode, data, arg, result);
 	else
-		return ieee1394_lock(handle, node, addr, extcode, data, arg, result);
+		ret = ieee1394_lock(handle, node, addr, extcode, data, arg, result);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_lock64(raw1394handle_t handle, nodeid_t node, nodeaddr_t addr,
                  unsigned int extcode, octlet_t data, octlet_t arg,
                  octlet_t *result)
 {
+	TRACEh1("raw1394_lock64(h = %d, node = 0x%x, addr = 0x%lx, extcode = %u, data, arg, result)", handle, node, addr, extcode);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_lock64(handle, node, addr, extcode, data, arg, result);
+		ret = fw_lock64(handle, node, addr, extcode, data, arg, result);
 	else
-		return ieee1394_lock64(handle, node, addr, extcode, data, arg, result);
+		ret = ieee1394_lock64(handle, node, addr, extcode, data, arg, result);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_async_stream(raw1394handle_t handle, unsigned int channel,
                          unsigned int tag, unsigned int sy, unsigned int speed,
                          size_t length, quadlet_t *data)
 {
+	TRACEh1("raw1394_stream(h = %d, channel = %u, tag, sy = %u, speed = %u, length = %ld, data)", handle, channel, sy, speed, length);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_async_stream(handle, channel, tag, sy, speed, length, data);
+		ret = fw_async_stream(handle, channel, tag, sy, speed, length, data);
 	else
-		return ieee1394_async_stream(handle, channel, tag, sy, speed, length, data);
+		ret = ieee1394_async_stream(handle, channel, tag, sy, speed, length, data);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_async_send(raw1394handle_t handle,
@@ -469,95 +660,130 @@
                        unsigned int expect_response,
                        quadlet_t *data)
 {
+	TRACEh1("raw1394_send(h = %d, length = %ld, header_length = %ld, expect_response = %u, data)", handle, length, header_length, expect_response);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_async_send(handle->mode.fw, length, header_length,
+		ret = fw_async_send(handle->mode.fw, length, header_length,
 			expect_response, data);
 	else
-		return ieee1394_async_send(handle, length, header_length,
+		ret = ieee1394_async_send(handle, length, header_length,
 			expect_response, data);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_start_fcp_listen(raw1394handle_t handle)
 {
+	TRACEh("raw1394_start_fcp_listen(h = %d)", handle);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_start_fcp_listen(handle->mode.fw);
+		ret = fw_start_fcp_listen(handle->mode.fw);
 	else
-		return ieee1394_start_fcp_listen(handle);
+		ret = ieee1394_start_fcp_listen(handle);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_stop_fcp_listen(raw1394handle_t handle)
 {
+	TRACEh("raw1394_stop_fcp_listen(h = %d)", handle);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_stop_fcp_listen(handle->mode.fw);
+		ret = fw_stop_fcp_listen(handle->mode.fw);
 	else
-		return ieee1394_stop_fcp_listen(handle);
+		ret = ieee1394_stop_fcp_listen(handle);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_update_config_rom(raw1394handle_t handle, const quadlet_t
         *new_rom, size_t size, unsigned char rom_version)
 {
+	TRACEh1("raw1394_update_config_rom(h = %d, new_rom, size = %lu, rom_version = %u)", handle, size, rom_version);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_update_config_rom(handle->mode.fw, new_rom, size, rom_version);
+		ret = fw_update_config_rom(handle->mode.fw, new_rom, size, rom_version);
 	else
-		return ieee1394_update_config_rom(handle->mode.ieee1394,
+		ret = ieee1394_update_config_rom(handle->mode.ieee1394,
 			new_rom, size, rom_version);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_get_config_rom(raw1394handle_t handle, quadlet_t *buffer,
         size_t buffersize, size_t *rom_size, unsigned char *rom_version)
 {
+	TRACEh1("raw1394_get_config_rom(h = %d, buffer, buffersize = %lu, rom_size, rom_version)", handle, buffersize);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_get_config_rom(handle->mode.fw, buffer, buffersize,
+		ret = fw_get_config_rom(handle->mode.fw, buffer, buffersize,
 			rom_size, rom_version);
 	else
-		return ieee1394_get_config_rom(handle->mode.ieee1394, buffer,
+		ret = ieee1394_get_config_rom(handle->mode.ieee1394, buffer,
 			buffersize, rom_size, rom_version);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_bandwidth_modify (raw1394handle_t handle, unsigned int bandwidth,
 	enum raw1394_modify_mode mode)
 {
+	TRACEh1("raw1394_bandwidth_modify(h = %d, bandwidth = %u, mode = %d)", handle, bandwidth, mode);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_bandwidth_modify(handle, bandwidth, mode);
+		ret = fw_bandwidth_modify(handle, bandwidth, mode);
 	else
-		return ieee1394_bandwidth_modify(handle, bandwidth, mode);
+		ret = ieee1394_bandwidth_modify(handle, bandwidth, mode);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_channel_modify (raw1394handle_t handle, unsigned int channel,
 	enum raw1394_modify_mode mode)
 {
+	TRACEh1("raw1394_bandwidth_modify(h = %d, channel = %u, mode = %d)", handle, channel, mode);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_channel_modify(handle, channel, mode);
+		ret = fw_channel_modify(handle, channel, mode);
 	else
-		return ieee1394_channel_modify(handle, channel, mode);
+		ret = ieee1394_channel_modify(handle, channel, mode);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_iso_xmit_init(raw1394handle_t handle,
@@ -568,16 +794,21 @@
                           enum raw1394_iso_speed speed,
                           int irq_interval)
 {
+	TRACEh1("raw1394_iso_xmit_init(h = %d, handler, buf_packets = %u, max_packet_size = %u, channel = %u, speed = %d, irq_interval = %d)", handle, buf_packets, max_packet_size, channel, speed, irq_interval);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_iso_xmit_init(handle->mode.fw, handler, buf_packets,
+		ret = fw_iso_xmit_init(handle->mode.fw, handler, buf_packets,
 			max_packet_size, channel, speed, irq_interval);
 	else
-		return ieee1394_iso_xmit_init(handle->mode.ieee1394, handler, buf_packets,
+		ret = ieee1394_iso_xmit_init(handle->mode.ieee1394, handler, buf_packets,
 			max_packet_size, channel, speed, irq_interval);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_iso_recv_init(raw1394handle_t handle,
@@ -588,16 +819,21 @@
                           enum raw1394_iso_dma_recv_mode mode,
                           int irq_interval)
 {
+	TRACEh1("raw1394_iso_recv_init(h = %d, handler, buf_packets = %u, max_packet_size = %u, channel = %u, mode = %d, irq_interval = %d)", handle, buf_packets, max_packet_size, channel, mode, irq_interval);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_iso_recv_init(handle->mode.fw, handler, buf_packets,
+		ret = fw_iso_recv_init(handle->mode.fw, handler, buf_packets,
 			max_packet_size, channel, mode, irq_interval);
 	else
-		return ieee1394_iso_recv_init(handle->mode.ieee1394, handler, buf_packets,
+		ret = ieee1394_iso_recv_init(handle->mode.ieee1394, handler, buf_packets,
 			max_packet_size, channel, mode, irq_interval);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_iso_multichannel_recv_init(raw1394handle_t handle,
@@ -606,126 +842,184 @@
                                        unsigned int max_packet_size,
                                        int irq_interval)
 {
+	TRACEh1("raw1394_iso_multichannel_recv_init(h = %d, handler, buf_packets = %u, max_packet_size = %u, irq_interval = %d)", handle, buf_packets, max_packet_size, irq_interval);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_iso_multichannel_recv_init(handle->mode.fw, handler, buf_packets,
+		ret = fw_iso_multichannel_recv_init(handle->mode.fw, handler, buf_packets,
 			max_packet_size, irq_interval);
 	else
-		return ieee1394_iso_multichannel_recv_init(handle->mode.ieee1394, handler,
+		ret = ieee1394_iso_multichannel_recv_init(handle->mode.ieee1394, handler,
 			buf_packets, max_packet_size, irq_interval);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_iso_recv_listen_channel(raw1394handle_t handle,
                                     unsigned char channel)
 {
+	TRACEh1("raw1394_iso_recv_channel(h = %d, channel = %u)", handle, channel);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_iso_recv_listen_channel(handle->mode.fw, channel);
+		ret = fw_iso_recv_listen_channel(handle->mode.fw, channel);
 	else
-		return ieee1394_iso_recv_listen_channel(handle->mode.ieee1394, channel);
+		ret = ieee1394_iso_recv_listen_channel(handle->mode.ieee1394, channel);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_iso_recv_unlisten_channel(raw1394handle_t handle,
                                       unsigned char channel)
 {
+	TRACEh1("raw1394_iso_recv_unlisten_channel(h = %d, channel = %u)", handle, channel);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_iso_recv_unlisten_channel(handle->mode.fw, channel);
+		ret = fw_iso_recv_unlisten_channel(handle->mode.fw, channel);
 	else
-		return ieee1394_iso_recv_unlisten_channel(handle->mode.ieee1394, channel);
+		ret = ieee1394_iso_recv_unlisten_channel(handle->mode.ieee1394, channel);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_iso_recv_set_channel_mask(raw1394handle_t handle, u_int64_t mask)
 {
+	TRACEh1("raw1394_iso_recv_set_channel_mask(h = %d, mask = %lu)", handle, mask);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_iso_recv_set_channel_mask(handle->mode.fw, mask);
+		ret = fw_iso_recv_set_channel_mask(handle->mode.fw, mask);
 	else
-		return ieee1394_iso_recv_set_channel_mask(handle->mode.ieee1394, mask);
+		ret = ieee1394_iso_recv_set_channel_mask(handle->mode.ieee1394, mask);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_iso_xmit_start(raw1394handle_t handle, int start_on_cycle,
                            int prebuffer_packets)
 {
+	TRACEh1("raw1394_iso_xmit_start(h = %d, start_on_cycle = %d, prebuffer_packets = %d)", handle, start_on_cycle, prebuffer_packets);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_iso_xmit_start(handle,
+		ret = fw_iso_xmit_start(handle,
 			start_on_cycle, prebuffer_packets);
 	else
-		return ieee1394_iso_xmit_start(handle->mode.ieee1394,
+		ret = ieee1394_iso_xmit_start(handle->mode.ieee1394,
 			start_on_cycle, prebuffer_packets);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_iso_recv_start(raw1394handle_t handle, int start_on_cycle,
                            int tag_mask, int sync)
 {
+	TRACEh1("raw1394_iso_recv_start(h = %d, start_on_cycle = %d, tag_mask = %d, sync = %d)", handle, start_on_cycle, tag_mask, sync);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_iso_recv_start(handle->mode.fw,
+		ret = fw_iso_recv_start(handle->mode.fw,
 			start_on_cycle, tag_mask, sync);
 	else
-		return ieee1394_iso_recv_start(handle->mode.ieee1394,
+		ret = ieee1394_iso_recv_start(handle->mode.ieee1394,
 			start_on_cycle, tag_mask, sync);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_iso_xmit_write(raw1394handle_t handle, unsigned char *data,
                            unsigned int len, unsigned char tag,
                            unsigned char sy)
 {
+#ifdef TRACELOOP
+	TRACEh1("raw1394_iso_xmit_write(h = %d, data, len = %u, tag = %u, sy = %u)", handle, len, tag, sy);
+	if(len >= 4)
+	{
+		TRACEquad("data", data, len);
+	}
+	else
+	{
+		TRACEchar("data", data, len);
+	}
+#endif
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_iso_xmit_write(handle, data, len, tag, sy);
+		ret = fw_iso_xmit_write(handle, data, len, tag, sy);
 	else
-		return ieee1394_iso_xmit_write(handle, data, len, tag, sy);
+		ret = ieee1394_iso_xmit_write(handle, data, len, tag, sy);
+
+#ifdef TRACELOOP
+	TRACEret1("%d", ret);
+#endif
+	return ret;
 }
 
 int raw1394_iso_xmit_sync(raw1394handle_t handle)
 {
+	TRACEh("raw1394_iso_xmit_sync(h = %d)", handle);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_iso_xmit_sync(handle);
+		ret = fw_iso_xmit_sync(handle);
 	else
-		return ieee1394_iso_xmit_sync(handle->mode.ieee1394);
+		ret = ieee1394_iso_xmit_sync(handle->mode.ieee1394);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 int raw1394_iso_recv_flush(raw1394handle_t handle)
 {
+	TRACEh("raw1394_iso_recv_flush(h = %d)", handle);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_iso_recv_flush(handle->mode.fw);
+		ret = fw_iso_recv_flush(handle->mode.fw);
 	else
-		return ieee1394_iso_recv_flush(handle->mode.ieee1394);
+		ret = ieee1394_iso_recv_flush(handle->mode.ieee1394);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
 
 void raw1394_iso_stop(raw1394handle_t handle)
 {
+	TRACEh("raw1394_iso_stop(h = %d)", handle);
 	if (!handle) {
 		return;
 	}
@@ -733,10 +1027,12 @@
 		fw_iso_stop(handle->mode.fw);
 	else
 		ieee1394_iso_stop(handle->mode.ieee1394);
+	TRACEret("");
 }
 
 void raw1394_iso_shutdown(raw1394handle_t handle)
 {
+	TRACEh("raw1394_iso_shutdown(h = %d)", handle);
 	if (!handle) {
 		return;
 	}
@@ -744,19 +1040,25 @@
 		fw_iso_shutdown(handle->mode.fw);
 	else
 		ieee1394_iso_shutdown(handle->mode.ieee1394);
+	TRACEret("");
 }
 
 int raw1394_read_cycle_timer(raw1394handle_t handle,
                              u_int32_t *cycle_timer, u_int64_t *local_time)
 {
+	TRACEh("raw1394_read_cycle_timer(h = %d, cycle_timer, local_time)", handle);
 	if (!handle) {
 		errno = EINVAL;
 		return -1;
 	}
+	int ret;
 	if (handle->is_fw)
-		return fw_read_cycle_timer(handle->mode.fw,
+		ret = fw_read_cycle_timer(handle->mode.fw,
 			cycle_timer, local_time);
 	else
-		return ieee1394_read_cycle_timer(handle->mode.ieee1394,
+		ret = ieee1394_read_cycle_timer(handle->mode.ieee1394,
 			cycle_timer, local_time);
+
+	TRACEret1("%d", ret);
+	return ret;
 }
diff -N -r -u /home/bzr/Downloads/libraw1394-2.0.5/src/eventloop.c ./src/eventloop.c
--- /home/bzr/Downloads/libraw1394-2.0.5/src/eventloop.c	2009-01-30 06:11:05.000000000 +0100
+++ ./src/eventloop.c	2010-09-01 10:08:40.000000000 +0200
@@ -27,17 +27,27 @@
 #include "kernel-raw1394.h"
 #include "raw1394_private.h"
 
+#include "trace.h"
+
 
 int ieee1394_loop_iterate(struct raw1394_handle *handle)
 {
         struct raw1394_request req;
         ieee1394handle_t ihandle = handle->mode.ieee1394;
         int retval = 0;
+#ifdef TRACELOOP
+        TRACEh("ieee1394_loop_iterate(h = %d)", handle); fflush(stdout);
+#endif
 
         while (read(ihandle->fd, &req, sizeof(req)) < 0) {
-                if (errno != EINTR) return -1;
+                if (errno != EINTR)
+		{
+#ifdef TRACELOOP
+			TRACEret1("read failed: errno = %d", errno);
+#endif
+			return -1;
+		}
         }
-
         switch (req.type) {
         case RAW1394_REQ_BUS_RESET:
                 if (ihandle->protocol_version == 3) {
@@ -88,7 +98,9 @@
                 }
                 break;
         }
-
+#ifdef TRACELOOP
+	TRACEret1("retval = %d\n", retval);
+#endif
         return retval;
 }
 
@@ -96,6 +108,7 @@
 bus_reset_handler_t raw1394_set_bus_reset_handler(struct raw1394_handle *handle,
                                                   bus_reset_handler_t new)
 {
+	TRACEh("raw1394_set_bus_reset_handler(h = %d, new)", handle);
 	bus_reset_handler_t old;
 	if (!handle) {
 		errno = EINVAL;
@@ -109,6 +122,7 @@
 		old = handle->mode.ieee1394->bus_reset_handler;
 		handle->mode.ieee1394->bus_reset_handler = new;
 	}
+	TRACEret("old_handle");
 	return old;
 }
 
@@ -147,12 +161,14 @@
 		old = handle->mode.ieee1394->arm_tag_handler;
 		handle->mode.ieee1394->arm_tag_handler = new;
 	}
+	TRACEret("old_handle");
 	return old;
 }
 
 fcp_handler_t raw1394_set_fcp_handler(struct raw1394_handle *handle,
                                       fcp_handler_t new)
 {
+	TRACEh("raw1394_set_fcp_handler(h = %d, new)", handle);
 	fcp_handler_t old;
 	if (!handle) {
 		errno = EINVAL;
@@ -166,5 +182,6 @@
 		old = handle->mode.ieee1394->fcp_handler;
 		handle->mode.ieee1394->fcp_handler = new;
 	}
+	TRACEret("old_handle");
 	return old;
 }
diff -N -r -u /home/bzr/Downloads/libraw1394-2.0.5/src/eventloop.c.orig ./src/eventloop.c.orig
--- /home/bzr/Downloads/libraw1394-2.0.5/src/eventloop.c.orig	1970-01-01 01:00:00.000000000 +0100
+++ ./src/eventloop.c.orig	2010-09-01 10:07:41.000000000 +0200
@@ -0,0 +1,170 @@
+/*
+ * libraw1394 - library for raw access to the 1394 bus with the Linux subsystem.
+ *
+ * Copyright (C) 1999,2000,2001,2002 Andreas Bombe
+ *                     2002 Manfred Weihs <weihs@ict.tuwien.ac.at>
+ *                     2002 Christian Toegel <christian.toegel@gmx.at>
+ *
+ * This library is licensed under the GNU Lesser General Public License (LGPL),
+ * version 2.1 or later. See the file COPYING.LIB in the distribution for
+ * details.
+ *
+ *
+ * Contributions:
+ *
+ * Manfred Weihs <weihs@ict.tuwien.ac.at>
+ *        address range mapping
+ * Christian Toegel <christian.toegel@gmx.at>
+ *        address range mapping
+ */
+
+#include <config.h>
+#include <unistd.h>
+#include <byteswap.h>
+#include <errno.h>
+
+#include "raw1394.h"
+#include "kernel-raw1394.h"
+#include "raw1394_private.h"
+
+
+int ieee1394_loop_iterate(struct raw1394_handle *handle)
+{
+        struct raw1394_request req;
+        ieee1394handle_t ihandle = handle->mode.ieee1394;
+        int retval = 0;
+
+        while (read(ihandle->fd, &req, sizeof(req)) < 0) {
+                if (errno != EINTR) return -1;
+        }
+
+        switch (req.type) {
+        case RAW1394_REQ_BUS_RESET:
+                if (ihandle->protocol_version == 3) {
+                        ihandle->num_of_nodes = req.misc & 0xffff;
+                        ihandle->local_id = req.misc >> 16;
+                } else {
+                        ihandle->num_of_nodes = req.misc & 0xff;
+                        ihandle->irm_id = ((req.misc >> 8) & 0xff) | 0xffc0;
+                        ihandle->local_id = req.misc >> 16;
+                }
+
+                if (ihandle->bus_reset_handler) {
+                        retval = ihandle->bus_reset_handler(handle,
+                                                           req.generation);
+                }
+                break;
+
+        case RAW1394_REQ_FCP_REQUEST:
+                if (ihandle->fcp_handler) {
+                        retval = ihandle->fcp_handler(handle, req.misc & 0xffff,
+                                                     req.misc >> 16,
+                                                     req.length,
+                                                     (unsigned char *)ihandle->buffer);
+                }
+                break;
+
+        case RAW1394_REQ_ARM:
+                if (ihandle->arm_tag_handler) {
+                        retval = ihandle->arm_tag_handler(handle, req.tag,
+                                 (req.misc & (0xFF)), 
+                                 ((req.misc >> 16) & (0xFFFF)),
+                                 int2ptr(req.recvb));
+                } 
+                break;
+                
+        case RAW1394_REQ_ECHO:
+                retval=req.misc;
+                break;
+
+        case RAW1394_REQ_RAWISO_ACTIVITY:
+                retval = _ieee1394_iso_iterate(handle);
+                break;
+        
+        default:
+                if (ihandle->tag_handler) {
+                        retval = ihandle->tag_handler(handle, req.tag,
+                                                     req.error);
+                }
+                break;
+        }
+
+        return retval;
+}
+
+
+bus_reset_handler_t raw1394_set_bus_reset_handler(struct raw1394_handle *handle,
+                                                  bus_reset_handler_t new)
+{
+	bus_reset_handler_t old;
+	if (!handle) {
+		errno = EINVAL;
+		return NULL;
+	}
+	if (handle->is_fw) {
+		old = handle->mode.fw->bus_reset_handler;
+		handle->mode.fw->bus_reset_handler = new;
+	}
+	else {
+		old = handle->mode.ieee1394->bus_reset_handler;
+		handle->mode.ieee1394->bus_reset_handler = new;
+	}
+	return old;
+}
+
+tag_handler_t raw1394_set_tag_handler(struct raw1394_handle *handle, 
+                                      tag_handler_t new)
+{
+	tag_handler_t old;
+	if (!handle) {
+		errno = EINVAL;
+		return NULL;
+	}
+	if (handle->is_fw) {
+		old = handle->mode.fw->tag_handler;
+		handle->mode.fw->tag_handler = new;
+	}
+	else {
+		old = handle->mode.ieee1394->tag_handler;
+		handle->mode.ieee1394->tag_handler = new;
+	}
+	return old;
+}
+
+arm_tag_handler_t raw1394_set_arm_tag_handler(struct raw1394_handle *handle, 
+                                      arm_tag_handler_t new)
+{
+	arm_tag_handler_t old;
+	if (!handle) {
+		errno = EINVAL;
+		return NULL;
+	}
+	if (handle->is_fw) {
+		old = handle->mode.fw->arm_tag_handler;
+		handle->mode.fw->arm_tag_handler = new;
+	}
+	else {
+		old = handle->mode.ieee1394->arm_tag_handler;
+		handle->mode.ieee1394->arm_tag_handler = new;
+	}
+	return old;
+}
+
+fcp_handler_t raw1394_set_fcp_handler(struct raw1394_handle *handle,
+                                      fcp_handler_t new)
+{
+	fcp_handler_t old;
+	if (!handle) {
+		errno = EINVAL;
+		return NULL;
+	}
+	if (handle->is_fw) {
+		old = handle->mode.fw->fcp_handler;
+		handle->mode.fw->fcp_handler = new;
+	}
+	else {
+		old = handle->mode.ieee1394->fcp_handler;
+		handle->mode.ieee1394->fcp_handler = new;
+	}
+	return old;
+}
diff -N -r -u /home/bzr/Downloads/libraw1394-2.0.5/src/eventloop.c.rej ./src/eventloop.c.rej
--- /home/bzr/Downloads/libraw1394-2.0.5/src/eventloop.c.rej	1970-01-01 01:00:00.000000000 +0100
+++ ./src/eventloop.c.rej	2010-09-01 10:09:14.000000000 +0200
@@ -0,0 +1,32 @@
+--- home/bzr/Downloads/libraw1394-2.0.5/src/eventloop.c	2009-01-30 06:11:05.000000000 +0100
++++ src/eventloop.c	2010-09-01 10:03:28.000000000 +0200
+@@ -122,12 +135,14 @@
+ 		old = handle->mode.ieee1394->bus_reset_handler;
+ 		handle->mode.ieee1394->bus_reset_handler = new;
+ 	}
++	TRACEret("old_handle");
+ 	return old;
+ }
+ 
+ tag_handler_t raw1394_set_tag_handler(struct raw1394_handle *handle,
+                                       tag_handler_t new)
+ {
++	TRACEh("raw1394_set_tag_handler(h = %d, new)", handle);
+ 	tag_handler_t old;
+ 	if (!handle) {
+ 		errno = EINVAL;
+@@ -141,12 +156,14 @@
+ 		old = handle->mode.ieee1394->tag_handler;
+ 		handle->mode.ieee1394->tag_handler = new;
+ 	}
++	TRACEret("old_handle");
+ 	return old;
+ }
+ 
+ arm_tag_handler_t raw1394_set_arm_tag_handler(struct raw1394_handle *handle,
+                                       arm_tag_handler_t new)
+ {
++	TRACEh("raw1394_set_arm_tag_handler(h = %d, new)", handle);
+ 	arm_tag_handler_t old;
+ 	if (!handle) {
+ 		errno = EINVAL;
diff -N -r -u /home/bzr/Downloads/libraw1394-2.0.5/src/fcp.c ./src/fcp.c
--- /home/bzr/Downloads/libraw1394-2.0.5/src/fcp.c	2008-08-07 04:51:17.000000000 +0200
+++ ./src/fcp.c	2010-09-01 10:08:04.000000000 +0200
@@ -17,8 +17,11 @@
 #include "kernel-raw1394.h"
 #include "raw1394_private.h"
 
+#include "trace.h"
+
 static int do_fcp_listen(struct raw1394_handle *handle, int startstop)
 {
+        TRACEh1("do_fcp_listen(h = %d, startstop = %d)", handle, startstop);
         ieee1394handle_t ihandle = handle->mode.ieee1394;
         struct sync_cb_data sd = { 0, 0 };
         struct raw1394_reqhandle rh = { (req_callback_t)_raw1394_sync_cb, &sd };
@@ -42,14 +45,17 @@
         switch (sd.errcode) {
         case RAW1394_ERROR_ALREADY:
                 errno = EALREADY;
+		TRACEret("returns -1, errno = EALREADY");
                 return -1;
 
         case RAW1394_ERROR_INVALID_ARG:
                 errno = EINVAL;
+		TRACEret("returns -1, errno = EINVAL");
                 return -1;
 
         default:
                 errno = 0;
+		TRACEret1("returns %d, errno = 0", sd.errcode);
                 return sd.errcode;
         }
 }
diff -N -r -u /home/bzr/Downloads/libraw1394-2.0.5/src/iso.c ./src/iso.c
--- /home/bzr/Downloads/libraw1394-2.0.5/src/iso.c	2008-08-07 04:51:17.000000000 +0200
+++ ./src/iso.c	2010-09-01 10:08:04.000000000 +0200
@@ -22,6 +22,8 @@
 #include "kernel-raw1394.h"
 #include "raw1394_private.h"
 
+#include "trace.h"
+
 /* This implements
    x = (x+1) % n
    using a branch based implementation
@@ -56,9 +58,13 @@
 	unsigned int stride;
 	int result;
 
+	TRACE1("do_iso_init(handle, buf_packets = %u, max_packet_size = %u, channel = %d, speed = %d, mode = %d, irq_interval = %d, cmd = 0x%x)", buf_packets, max_packet_size, channel, speed, mode, irq_interval, cmd);
+
 	/* already initialized? */
-	if(handle->iso_mode != ISO_INACTIVE)
+	if(handle->iso_mode != ISO_INACTIVE) {
+  	TRACEret("failed: already active");
 		return -1;
+  }
 
 	/* choose a power-of-two stride for the packet data buffer,
 	   so that an even number of packets fits on one page */
@@ -66,6 +72,7 @@
 
 	if(stride > getpagesize()) {
 		errno = ENOMEM;
+  	TRACEret("failed ENOMEM");
 		return -1;
 	}
 
@@ -79,7 +86,10 @@
 	handle->iso_status.config.dma_mode = mode;
 
 	if(ioctl(handle->fd, cmd, &handle->iso_status))
+  {
+  	TRACEret("failed");
 		return -1;
+  }
 
 	/* mmap the DMA buffer */
 	/* (we assume the kernel sets buf_size to an even number of pages) */
@@ -91,6 +101,7 @@
 	if(handle->iso_buffer == (unsigned char*) MAP_FAILED) {
 		handle->iso_buffer = NULL;
 		ioctl(handle->fd, RAW1394_IOC_ISO_SHUTDOWN, 0);
+  	TRACEret("failed");
 		return -1;
 	}
 
@@ -107,6 +118,7 @@
 		munmap(handle->iso_buffer, handle->iso_status.config.data_buf_size);
 		handle->iso_buffer = NULL;
 		ioctl(handle->fd, RAW1394_IOC_ISO_SHUTDOWN, 0);
+  	TRACEret("failed");
 		return -1;
 	}
 #if _POSIX_MEMLOCK > 0
@@ -116,9 +128,11 @@
 		munmap(handle->iso_buffer, handle->iso_status.config.data_buf_size);
 		handle->iso_buffer = NULL;
 		ioctl(handle->fd, RAW1394_IOC_ISO_SHUTDOWN, 0);
+  	TRACEret("failed");
 		return -1;
 	}
 #endif
+	TRACEret("ok");
 	return 0;
 }
 
@@ -243,6 +257,9 @@
 	struct raw1394_iso_packets packets;
 	int retval = -1;
 	int stop_sync = 0;
+#ifdef TRACELOOP
+        TRACEh("_iso_xmit_queue_packets(h = %d)", handle); fflush(stdout);
+#endif
 
 	if(ihandle->iso_mode != ISO_XMIT) {
 		errno = EINVAL;
@@ -321,7 +338,9 @@
 			return -1;
 		ieee1394_iso_stop(ihandle);
 	}
-	
+#ifdef TRACELOOP
+	TRACEret1("retval=%d", retval);
+#endif
 	return retval;
 }
 
@@ -458,7 +477,9 @@
 	struct raw1394_iso_packets packets;
 
 	int retval = -1, packets_done = 0;
-
+#ifdef TRACELOOP		
+        TRACEh("_iso_recv_packets(h = %d)", handle); fflush(stdout);
+#endif
 	if(ihandle->iso_mode != ISO_RECV) {
 		errno = EINVAL;
 		return -1;
@@ -480,12 +501,40 @@
 		info = &packets.infos[packets_done];
 
 		/* call handler */
-		disp = ihandle->iso_recv_handler(handle,
+		{
+			unsigned int dropped = _iso_dropped(ihandle);
+#ifdef TRACELOOP		
+//			printf("\033[f\n\n"); // Go to top-left of screen (prevents scrolling)
+			TRACEh1("Calling handler (h = %d, buf, len = %u, channel = %u, tag = %u, cycle = %u, dropped)", handle, info->len, info->channel, info->tag, info->sy, info->cycle);
+			TRACEquad("buf", (ihandle->iso_buffer + info->offset), 32);
+			TRACEquad("buf", (ihandle->iso_buffer + info->offset + 32), 32);
+			int i;
+			struct data_read* dr = ((struct data_read *) (ihandle->iso_buffer + info->offset));
+			printf("Status bits (%2.2x):", dr->status.bits);
+			for(i = 0; i < 8; i++)
+			  printf("%d->%d ", i, (dr->status.bits & (1<<i))!=0);
+			printf("\n");
+			if(dr->status.bit3 != 0)
+			  printf("Status bit3 has unexpected (new) value! Check how this happened and find out meaning of this bit\n");
+			if(dr->status.bit4 != 1)
+			  printf("Status bit4 has unexpected (new) value! Check how this happened and find out meaning of this bit\n");
+			if(dr->status.bit5 != 0)
+			  printf("Status bit5 has unexpected (new) value! Check how this happened and find out meaning of this bit\n");
+			if(dr->status.bit6 != 0)
+			  printf("Status bit6 has unexpected (new) value! Check how this happened and find out meaning of this bit\n");
+			if(dr->status.bit7 != 1)
+			  printf("Status bit7 has unexpected (new) value! Check how this happened and find out meaning of this bit\n");
+#endif
+			disp = ihandle->iso_recv_handler(handle,
 						ihandle->iso_buffer + info->offset,
 						info->len, info->channel,
 						info->tag, info->sy,
 						info->cycle,
-						_iso_dropped(ihandle));
+						dropped);
+#ifdef TRACELOOP		
+			TRACEret1("disp = %d", disp);
+#endif		
+		}
 
 		/* advance packet cursors */
 		stat->n_packets--;
@@ -512,7 +561,10 @@
 		if(ioctl(ihandle->fd, RAW1394_IOC_ISO_RECV_RELEASE_PACKETS, packets_done))
 			retval = -1;
 	}
-out:	
+out:
+#ifdef TRACELOOP
+	TRACEret1("retval=%d", retval);
+#endif
 	return retval;
 }
 
@@ -521,29 +573,53 @@
 {
 	ieee1394handle_t ihandle = handle->mode.ieee1394;
 	int err;
+#ifdef TRACELOOP
+        TRACEh("_ieee1394_iso_iterate(h = %d)", handle); fflush(stdout);
+#endif
 
 	if(ihandle->iso_mode == ISO_INACTIVE)
+	{
+#ifdef TRACELOOP
+		TRACEret("ISO_INACTIVE");
+#endif
 		return 0;
+	}
 
 	err = ioctl(ihandle->fd, RAW1394_IOC_ISO_GET_STATUS, &ihandle->iso_status);
 	if(err != 0)
+	{
+#ifdef TRACELOOP
+		TRACEret1("ioctl failed: err = %d", err);
+#endif
 		return err;
+	}
 
 	ihandle->iso_packets_dropped += ihandle->iso_status.overflows;
 
 	if(ihandle->iso_state == ISO_GO) {
 		if(ihandle->iso_mode == ISO_XMIT) {
 			if(ihandle->iso_xmit_handler) {
-				return _iso_xmit_queue_packets(handle);
+				int ret = _iso_xmit_queue_packets(handle);
+#ifdef TRACELOOP
+				TRACEret1("ret=%d", ret);
+#endif
+				return ret;
 			}
 		}
 
 		if(ihandle->iso_mode == ISO_RECV) {
 			if(ihandle->iso_recv_handler) {
-				return _iso_recv_packets(handle);
+				int ret = _iso_recv_packets(handle);
+#ifdef TRACELOOP
+				TRACEret1("ret=%d", ret);
+#endif
+				return ret;
 			}
 		}
 	}
 
+#ifdef TRACELOOP
+	TRACEret("nothing to do...");
+#endif
 	return 0;
 }
diff -N -r -u /home/bzr/Downloads/libraw1394-2.0.5/src/Makefile.am ./src/Makefile.am
--- /home/bzr/Downloads/libraw1394-2.0.5/src/Makefile.am	2009-06-22 06:22:25.000000000 +0200
+++ ./src/Makefile.am	2010-09-01 10:08:04.000000000 +0200
@@ -27,7 +27,9 @@
 	dispatch.c        \
 	fw.c              \
 	fw-iso.c          \
-	fw.h
+	fw.h              \
+	trace.c           \
+	trace.h
 
 
 # headers to be installed
diff -N -r -u /home/bzr/Downloads/libraw1394-2.0.5/src/Makefile.in ./src/Makefile.in
--- /home/bzr/Downloads/libraw1394-2.0.5/src/Makefile.in	2009-12-27 02:08:25.000000000 +0100
+++ ./src/Makefile.in	2010-09-01 10:08:04.000000000 +0200
@@ -54,7 +54,7 @@
 LTLIBRARIES = $(lib_LTLIBRARIES)
 libraw1394_la_LIBADD =
 am_libraw1394_la_OBJECTS = main.lo eventloop.lo errors.lo readwrite.lo \
-	iso.lo fcp.lo arm.lo version.lo dispatch.lo fw.lo fw-iso.lo
+	iso.lo fcp.lo arm.lo version.lo dispatch.lo fw.lo fw-iso.lo trace.lo
 libraw1394_la_OBJECTS = $(am_libraw1394_la_OBJECTS)
 libraw1394_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
 	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
@@ -213,6 +213,8 @@
 	dispatch.c        \
 	fw.c              \
 	fw-iso.c          \
+	trace.c           \
+	trace.h           \
 	fw.h
 
 
@@ -293,6 +295,7 @@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/eventloop.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fcp.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fw-iso.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/trace.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/fw.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/iso.Plo@am__quote@
 @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/main.Plo@am__quote@
diff -N -r -u /home/bzr/Downloads/libraw1394-2.0.5/src/trace.c ./src/trace.c
--- /home/bzr/Downloads/libraw1394-2.0.5/src/trace.c	1970-01-01 01:00:00.000000000 +0100
+++ ./src/trace.c	2010-09-01 10:08:04.000000000 +0200
@@ -0,0 +1,54 @@
+#include "stdio.h"
+#include "stdarg.h"
+#include "trace.h"
+
+int trace_ident = 0;
+
+struct handle_conversion {
+    raw1394handle_t handle;
+    int active;
+};
+
+#define MAX_NUMBER_OF_HANDLES 256
+struct handle_conversion handles[MAX_NUMBER_OF_HANDLES];
+int next_handle_number = 0;
+
+int get_handle_number(raw1394handle_t handle)
+{
+  int i;
+  for(i = 0; i < next_handle_number; i++)
+    if(handles[i].handle == handle && handles[i].active)
+      return i; // Found handle!
+
+  // Did not find handle, so add a new one to the list
+  if(next_handle_number == MAX_NUMBER_OF_HANDLES)
+  {
+      TRACE("Maximum number of handles reached... Increase MAX_NUMBER_OF_HANDLES!")
+      return -1;
+  }
+  handles[next_handle_number].handle = handle;
+  handles[next_handle_number].active = 1;
+  next_handle_number++;
+  return next_handle_number - 1;
+}
+
+int get_ieee1394_handle_number(struct ieee1394_handle *handle)
+{
+  int i;
+  for(i = 0; i < next_handle_number; i++)
+    if(handles[i].handle->mode.ieee1394 == handle && handles[i].active)
+      return i; // Found handle!
+  return -1; // Did not find...
+}
+
+void remove_handle_number(raw1394handle_t handle)
+{
+  int i;
+  for(i = 0; i < next_handle_number; i++)
+    if(handles[i].handle == handle && handles[i].active)
+    {
+      handles[i].active = 0;
+      return; // removed handle!
+    }
+  TRACEh("Could not find handle %d to remove it...", handle);
+}
diff -N -r -u /home/bzr/Downloads/libraw1394-2.0.5/src/trace.h ./src/trace.h
--- /home/bzr/Downloads/libraw1394-2.0.5/src/trace.h	1970-01-01 01:00:00.000000000 +0100
+++ ./src/trace.h	2010-09-01 10:08:04.000000000 +0200
@@ -0,0 +1,93 @@
+// Some custom macros to help debugging
+
+#pragma once
+
+#include "raw1394_private.h"
+#include "raw1394.h"
+
+#include "stdio.h"
+#include "stdarg.h"
+
+// Comment to disable tracing functionality
+#define USETRACE
+
+// Comment to disable tracing the loop iterate functions (saves loads of output)
+//#define TRACELOOP
+
+#ifdef USETRACE
+#  define TRACE(str)                     { printf("%12s:%4d %*s-> " str "\n", __FILE__, __LINE__, trace_ident, ""); trace_ident++; }
+#  define TRACE1(str, args...)           { printf("%12s:%4d %*s-> " str "\n", __FILE__, __LINE__, trace_ident, "", args); trace_ident++; }
+#  define TRACEh(str, handle)            { printf("%12s:%4d %*s-> " str "\n", __FILE__, __LINE__, trace_ident, "", get_handle_number(handle)); trace_ident++; }
+#  define TRACEh1(str, handle, args...)  { printf("%12s:%4d %*s-> " str "\n", __FILE__, __LINE__, trace_ident, "", get_handle_number(handle), args); trace_ident++; }
+#  define TRACEret(str)                  { trace_ident--; printf("%12s:%4d %*sexit " str "\n", __FILE__, __LINE__, trace_ident, ""); }
+#  define TRACEret1(str, value)          { trace_ident--; printf("%12s:%4d %*sexit: " str "\n", __FILE__, __LINE__, trace_ident, "", value); }
+#  define TRACEchar(str,buf,len)         { int i; printf("      " str ": "); for(i = 0; i < len; i++) printf("0x%2.2x ", ((unsigned char *) buf)[i]); printf("\n"); }
+#  define TRACEquad(str,buf,len)         { int i; printf("      " str ": "); for(i = 0; i < len; i+=4) printf("0x%8.8x ", ((quadlet_t *) (((char *) buf) + i))[0]); printf("\n"); }
+#else
+#  define TRACE(str)
+#  define TRACE1(str, args...)
+#  define TRACEh(str, handle)
+#  define TRACEh1(str, handle, args...)
+#  define TRACEret(str)
+#  define TRACEret1(str, value)
+#  define TRACEchar(str,buf, len)
+#  define TRACEquad(str,buf, len)
+#endif
+
+/**
+ * Contains the values of the gimbal. For each axis the 5 most LSB are unused (too erratic)
+ */
+union gimbal_u {
+  unsigned short raw[3];
+  struct {
+    unsigned short x_unused:5;
+    unsigned short x:11;
+    unsigned short y_unused:5;
+    unsigned short y:11;
+    unsigned short z_unused:5;
+    unsigned short z:11;
+  };
+};
+
+/**
+ * Data structure of the data presented when the read callback handler is called
+ */
+struct data_read {
+    short unknown0; // always 0x0000 ??
+    short unknown1; // always 0x001e ??
+    unsigned short encoder_x;
+    unsigned short encoder_y;
+    unsigned short encoder_z;
+    union gimbal_u gimbal;
+    short unknown8;
+    unsigned char  unknown9a; // Also status bits?
+    union {
+      unsigned char bits;
+      struct {
+        unsigned char button1 : 1; // When 0 the button is pressed
+        unsigned char button2 : 1; // When 0 the button is pressed
+        unsigned char docked  : 1; // When 0 the gimbal is docked
+        unsigned char bit3    : 1;
+        unsigned char bit4    : 1;
+        unsigned char bit5    : 1;
+        unsigned char bit6    : 1;
+        unsigned char bit7    : 1;
+      };
+    } status;
+    short unknown10; // always 0x1007 -> not always: also have seen 0x0007
+    union gimbal_u gimbal_inv; // seems to be the inverse of gimbal
+    short unknown14; // always 0x5746
+    short unknown15;
+    quadlet_t count0; // msg nr?? since this value is increawed by one every time a messege is received (even when app is not running)
+    short unknown18;
+    short unknown19;
+    short count1; // Seems to be counting, slower than count0 (half the speed?)
+    short unknown21;
+    // After this: all zeros (not part of data anymore?)
+};
+
+
+extern int trace_ident;
+extern int get_ieee1394_handle_number(struct ieee1394_handle *handle);
+extern int get_handle_number(raw1394handle_t handle);
+extern void remove_handle_number(raw1394handle_t handle);
